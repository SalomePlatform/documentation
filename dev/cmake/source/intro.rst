Introduction
============
This documentation describes the goals and the good practices to be applied when writing
the CMake files for the configuration of a SALOME module.

This documentation is best browsed with the KERNEL sources at hand, in order to be able to 
take a look at code snipets. Most references in this document points to KERNEL sources.

Motivations: CMake must be user friendly
========================================

Every beginner should be able to build SALOME, without any previous knowledge of SALOME. With a tool like cmake-gui, the user must obtain useful messages to find what is wrong or missing.

* CMake generates a build process which is per default much less verbose than the Autotools one. One doesn't see automatically
  the compilation/linking commands being invoked. Each of the following solutions displays the full command line for each build 
  action:  
  ::
    make VERBOSE=1
    env VERBOSE=1 make
    export VERBOSE=1; make

  To have this by default for every build, this can be specified at the configuration step by setting the 
  CMAKE_VERBOSE_MAKEFILE to ON.

* Only take into account first order prerequisites.
For instance, CASCADE uses Tbb : 
-	CASCADE is a prerequisite of first order of GUI,
-	Tbb is a prerequisite of second order of GUI,
-	GUI CMake files must reference explicitly CASCADE, but never Tbb. For detection and link, Tbb library may be needed in LD_LIBRARY_PATH in the environment of CMake.

* Take into account several versions of the same product, in the system, or generated by the user. 
For instance, system with python 2.7 and 3.2, and user python 2.6.

* Detection of prerequisite is driven by user options.
For example MPI is detected only if option SALOME_USE_MPI is ON.
For prerequisites variables, the naming convention is based on a CMake prefix:
<Product>_myVariable
<Product>_ROOT_DIR designing the root directory of the product in environment and CMake variables.

*	Detection of first order prerequisites is based on a <Product>_ROOT_DIR variable or on what has been detected in another dependencr. For example if both HDF5 and MPI are needed by the current module, we try to detect with which MPI installation HDF5 was compiled, and to offer this one as a default choice for the package itself. Other variables (PATH, LD_LIBRARY_PATH, PYTHONPATH) are not needed, except in very specific cases (Pythonâ€¦).


Package detection mechanism
===========================

Philosophy and priority order
-----------------------------

The philosophy of the SALOME package detection is to rely as 
much as possible on the standard CMake modules.
It is assumed those modules will get better and better with newer releases of CMake
and doing so ensures future compatibility with newer versions of CMake.

The detection is however guided through a variable of the form XYZ_ROOT_DIR which
gives the root directory of an installation of the package. For example, to indicate
that we wish to use the Python installed on the host system, one sets PYTHON_ROOT_DIR to
"/usr".

The variable guiding the detection is always builts as
::
  XYZ_ROOT_DIR

where <XYZ> is the upper case name of the standard CMake module. For example, the
detection of Qt4 is guided by setting QT4_ROOT_DIR.

Thus the priority for the detection of a package is (from high to low priority):
1. CMake variables explicitly set by the user on the command line
2. Environment variables set by the user (typically XYZ_ROOT_DIR, with WYZ the package to be detected)
3. Default value based on a previous dependency using the tool already
4. Detection in the host system

Writing the detection macro of a new prerequisite
-------------------------------------------------

All prerequisite detection in SALOME should be implemented by:
* writing a file FindSalome<Xyz>.cmake, where <Xyz> matches *exactly* the 




Implementation details
----------------------



This detection is guided using the XYZ_ROOT_DIR. Those variables
overr

If the standard FindXYZ.cmake macro exists (and works fine!)
it should be used as much as possible to ensure future
compatibility with newer versions of CMake.
The assumption is that those will become better and better
and we should automatically benefit from the enhancements.

All packages




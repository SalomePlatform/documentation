Introduction
============
CMake is a configuration tool generating the build chain (e.g. Makefiles on Linux)
of a software project.

This documentation describes the goals and the good practices to be applied when writing
the CMake files for the configuration of a SALOME module.

This documentation is best browsed with the SALOME KERNEL sources at hand, in order to be able to 
take a look at code snipets. Most references in this document points to KERNEL sources.

The section marked as ADVANCED need not be read by someone only trying to compile SALOME. Those
sections are intented to the core SALOME developpers, to help them understand/fix/improve
the process.

Motivations and overview
========================

CMake must be user-friendly
---------------------------

Every beginner should be able to build SALOME, without any previous knowledge of SALOME. 
With a tool like cmake-gui or ccmake, the user must obtain useful messages to find what is wrong or missing.

The general philosophy is thus to allow a developper to build SALOME with a minimal effort, setting only the 
minimal environment. 

Basic usage
-----------
Once the sources have been retrieved (via a clone of the repository or an extraction of the tarball)
once typically:
* create a dedicated build directory, e.g. KERNEL_BUILD
* switch to it, and invoke the ccmake (or cmake-gui) command
  ::
     ccmake ../KERNEL_SRC
* sets all the xyz_ROOT_DIR to point to the root paths of the package <xyz>
* sets the installation directory in the variable CMAKE_INSTALL_PREFIX
* generates the build files (hiting 'g' under ccmake)
* invoke the make command in the usual way:
  ::
     make
     make install

If you want to use a specific Python installation to configure and build SALOME, you should ensure that:
* the interpreter is in your path
* the variables LD_LIBRARY_PATH (PATH under Windows) and PYTHONPATH are properly pointing to your 
  desired Python installation.

Overview of the logic (advanced)
--------------------------------

Here are the general principles guiding the implementation:

* Only take into account first order prerequisites.
  For instance, CASCADE uses Tbb : 
    * CASCADE is a prerequisite of first order of GUI,
    * Tbb is a prerequisite of second order of GUI,
    * GUI CMake files must reference explicitly CASCADE, but never Tbb. The detection logic of CASCADE should make sure Tbb gets included.
* Being able to use different versions/installations of the same product, in the system, or generated by the user. 
  For instance, using the system python 2.7, or a user-compiled python 2.6.
* The detection of prerequisites is driven by user options.
  For example MPI is detected only if option SALOME_USE_MPI is ON.
*	Detection of first order prerequisites is based on a <Product>_ROOT_DIR variable or on what has been detected in 
  another   dependency. For example if both HDF5 and MPI are needed by the current module, we try to detect 
  with which MPI installation HDF5 was compiled, and to offer this one as a default choice for the package itself. 
  Other variables (PATH, LD_LIBRARY_PATH, PYTHONPATH) should never be needed at compile time.
* The only exception to the previous point is Python, which is so central to the process
  that we assume that LD_LIBRARY_PATH and PYTHONPATH are already correctly pointing to the correct
  Python installation.



